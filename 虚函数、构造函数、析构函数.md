## 构造函数不能是虚函数

1. 从存储空间角度
    虚函数对应一个vtable，而这个vtable是存储在对象的内存空间的，也就是说，**如果构造函数是虚函数，就需要通过vtable来调用，可对象就是通过构造函数来实例化的，实例化之前尚没有内存空间**（衍生出“先有鸡还是先有蛋的问题”），所以构造函数不能是虚函数；

2. 从使用角度
    虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用，特别**允许调用一个只知道接口而不知道其准确对象类型的函数；而构造函数本身就是要初始化对象，势必要知道对象的准确类型**，所以构造函数不能是虚函数；

3. 从作用
    虚函数的作用在于**通过基类的指针或引用来调用它的时候能够变成调用派生类的那个成员函数**，而**构造函数是在创建对象时自动调用的，不可能通过基类的指针或者引用去调用**，所以构造函数不能是虚函数；

### 总结

    vtable在构造函数调用后才建立，因而构造函数不可能成为虚函数；
    在调用构造函数时还不能确定对象的真实类型，因为派生类会调用基类的构造函数
    而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有必要成为虚函数。

## 析构函数可以是虚函数，甚至是纯虚函数

在面向对象的编程过程中，基类的指针或引用通常会指向基类或派生类对象

+ **如果基类的析构函数不是虚函数，在通过删除指针或引用来释放对象时，只会调用基类的析构函数，而不会调用派生类的析构函数，从而导致内存泄漏**
+ 反之，如果基类的析构函数是虚函数，就不会发生这类问题；因此，当一个类打算被用作其它类的基类时，它的析构函数必须是虚函数