![1583209904159](.\1583209904159.png)

![1583210325494](.\1583210325494.png)

# 三次挥手

所谓的三次挥手即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务器端总共发送3个包用以确认连接的建立。

在 socket编程中，这一过程由客户端执行connect来触发

![1586528483005](.\1586528483005.png)

## 具体过程

![1583681126672](.\1583681126672.png)

+ 第一次握手：客户端将标志位SYN置为1 ，随机产生一个值Seq=J，并将该数据包发送给服务器，客户端进入SYN_SENT状态，等待服务器确认
+ 第二次握手：服务器收到数据包后由标志位SYN=1，知道客户端请求建立连接，服务器将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值Seq=K，并将该数据包发送给客户端用以确认连接请求，服务器进入SYN_RCVD状态
+ 第三次握手：客户端收到确认后，检查ack是否为 J+1 ，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器，服务器检查ack是否为 K+1，ACK 是否为1，如果正确则连接建立成功，客户端和服务器进入ESTABLISHED状态
+ 完成三次握手，随后客户端和服务器之间可以开始传输数据了

## SYN攻击

在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接，此时服务器处于SYN_RCVD状态，当收到ACK后，服务器转入ESTABLISHED状态。

SYN攻击就是客户端在短时间内伪造大量不存在的IP地址，并向服务器不断地发送SYN包，服务器回复确认包，并等待客户端的确认，由于源地址是不存在的，因此，服务器需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接 队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击是一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当服务器上有大量半连接状态且源IP地址是随机的，则可以断定遭到了SYN攻击，可以使用#netstat -anp | grep SYN_RCVD进行查看

## 为什么要有第三次握手

第三次握手是为了防止已经失效的连接请求报文段突然又传送到了服务器端，从而产生错误

这个已经失效的连接报文段是怎么来的？

因为客户端在发送了SYN数据报后可能有这种情况，因为当时网络堵塞，所以过了超时重传的等待时间后客户端没有收到服务端的确认，所以它又发送了第二次SYN报文段，此时服务器发送过来了SYN应答报文段。但是可能过了一会，刚刚处于拥塞环境的SYN报文段又到达了服务器，这时服务器会认为客户端想和自己建立第二次连接，于是又向客户端发送了SYN应答报文段，而此时客户端可能已经完成了数据传输并释放了和服务器的连接，它的状态会变为CLOSED，从而导致永远无法收到服务端发来的SYN报文段，从而使服务器一致在等待客户端发来数据，这样会浪费许多服务端的资源

所以，就引入了第三次握手，例如上面的情况，客户端在收到应答报文段后不会向服务器再次发送确认，所以服务端也就无法建立连接



# 四次挥手

所谓四次挥手，即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务器总共发送四个包以确认连接的断开

在socket编程中，这一过程由客户端或服务器任一方执行close来触发

![1586529355858](.\1586529355858.png)

## 具体过程

![1583681106372](.\1583681106372.png)

由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方也发送了FIN（首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭）

+ 第一次挥手：客户端发送 一个FIN，用来关闭客户端到服务器的数据传送，客户端进入FIN_WAIT_1状态
+ 第二次挥手：服务器收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务器进入CLOSE_WAIT状态
+ 第三次挥手：服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态
+ 第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器，确认序号为收到序号+1，服务器进入CLOSED状态，完成四次挥手

## 为什么在最后一次挥手要等待2*MSL的时间

这样做是为了保证A的最后一次挥手（ACK报文段）能够到达B。出了LAST_ACK状态的B如果收不到A的ACK字段，那么他会在重传一次FIN+ACK字段，A收到后会重传一次确认，重新启动时间等待计时器（2\*MSL），如果A不等待 2*MSL，如果最后一次确认没有传到B，那么B的重传A就再也收不到了，那么B就会一直重传，并永远无法释放连接

## 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文

## 为什么连接的时候是三次握手，关闭的时候却是四次握手？

#### 【解答1】

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手

#### 【解答2】

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。



# 举例说明

比如你走在路上，发现前面有你的朋友向你走过来，你向你朋友挥手（**第一次握手**）。

你朋友看见了你向他打招呼，但是你朋友因为距离你太远，并不确定是否是跟他打招呼的，因此，你朋友用手指了下自己，并向你示意（**第二次握手**）。

你看见了你朋友的表情和动作，你需要给你朋友一个肯定，此时，你点头示意（**第三次握手**）。

此时你和你朋友互相聊天（`TCP已连接`）



你和你朋友聊天，聊着聊着，突然想起来女朋友钥匙丢了，你是回家开门的，现在耽误了半小时了，吓得冷汗都出来了，一想起榴莲。。。

这个时候，你赶紧跟你朋友说了情况，你说你马上得回去了，下次再聊（**第一次挥手**）。

你朋友听了，觉得也是得赶紧回去，就跟你说你赶紧回去吧。（**第二次挥手**）。

然后，你朋友走了，并向你挥手道别（**第三次挥手**）。

你看见你朋友跟你道别，你同样也跟你朋友道别（**第四次挥手**）。

回去之后，你就需要玩玩你的榴莲了