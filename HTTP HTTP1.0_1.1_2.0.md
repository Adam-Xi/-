# HTTP

HTTP：超文本传输协议，**是基于TCP/IP的关于数据在万维网中如何通信的协议** 

设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法

HTTP报文由客户机到服务器的请求和服务器到客户机的响应构成

HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性。如TCP建立连接时三次握手有1.5个RTT（发送一个数据包到收到对端ACK所花费的时间）的延迟，为了避免每次请求的都经历握手带来的延迟，应用层会选择不同策略的http长链接方案。又如TCP在建立连接的初期有慢启动（slow start）的特性，所以连接的重用总是比新建连接性能要好

HTTP连接使用的是“请求	·—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据 

#### 请求报文格式如下：

请求行 － 请求头 － 请求包体

**请求行**：请求行由URL字段、方法字段 和HTTP协议版本字段3个部分组成，之间用空格隔开。

**请求头**：请求头包含关于客户端请求的信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。

**请求包体**：请求包体不在GET方法中使用，而是在POST方法中使用（提交表单）。与请求包体相关的最常使用的是包体类型 Content-Type 和包体长度 Content-Length。

#### 应答报文格式如下：

状态行 － 响应头 －  响应包体

**状态行**：状态行由HTTP协议版本字段、状态码和状态码的描述文本3个部分组成，之间用空格隔开。

**响应头**：响应头包含服务端的响应信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。

**响应包体**：服务器返回给客户端的文本信息

![1584586821508](.\image\1584586821508.png)

![1584587435085](.\image\1584587435085.png)

![1584587460877](.\image\1584587460877.png)

# HTTP状态码

| 分类 | 分类描述                                       |
| ---- | ---------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

状态码主要是为了告知从服务器端返回的请求结果。

##### 2XX成功，请求正常处理完毕

+  **200 OK** 从客户端发送的请求在服务端被正常处理了。
+  **204 No Content** 服务器接受的请求已成功处理，但返回的响应报文的主体部分不包含实体（浏览器页面不更新，仅发送信息给服务器）
+  **206 Partial Content** 客户端进行了范围请求，而服务器成功执行了这部分请求

#####  3XX重定向，浏览器需要执行某些特殊的处理以正确处理请求。

+  **301 Moved Permanently** 永久性重定向，请求的资源已经分配了新的URI，以后应该使用资源现在所指的URI
+  **302 Found** 临时性重定向，请求的资源临时分配了新的URL，希望用户本次可以使用新的URI访问
   注意：当301,302,303响应状态码返回时，几乎所有的浏览器会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送
+  **304 Not Modified** 服务器端资源未改变，可直接使用客户端未过期的缓存，不包含任何响应的主体部分

##### 4XX客户端错误,客户端发生错误

+  **400 Bad Request**  请求报文中存在语法错误
+  **401 Unauthorized** 请求需要有通过HTTP认证的认证信息。另外如果之前已进行一次请求，则表示用户认证失败
+  **403 Forbidden** 对请求资源的访问被服务器拒绝了，如未获得文件系统的访问授权，访问权限出现某些问题
+  **404 Not Found** 服务器上没有请求的资源
+  **499 client has closed connection** 服务器端处理的时间过长，客户端主动断开链接，ngix定义的状态码

##### 5XX服务器错误，服务器发生错误

+  **500 Internal Server Error** 服务器在执行请求时发生了错误，Bug或临时故障
+  **503 Service Unavailable** 服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求



### HTTP1.0和HTTP1.1区别

主要区别主要体现在：

1. **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since, Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since，If-Match，If-None-Match等更多可供选择的缓存头来控制缓存策略。
2. **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在**请求头引入了range头域**，它允许**只请求资源的某个部分**，即返回码是**206**（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3. **错误通知的管理**，在HTTP1.1中**新增了24个错误状态响应码**，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4. **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在**一台物理服务器上可以存在多个虚拟主机**（Multi-homed Web Servers），并且它们**共享一个IP地址**。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
5. **长连接**，HTTP 1.1支持**长连接**（PersistentConnection）和**请求的流水线（Pipelining）处理**，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启**Connection： keep-alive**，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点



### SPDY：HTTP1.x的优化

2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：

1. **降低延迟**，针对HTTP高延迟的问题，SPDY优雅的采取了**多路复用**（multiplexing）。**多路复用给多个请求stream共享一个tcp连接**，降低了延迟同时提高了带宽的利用率。
2. **请求优先级**（request prioritization）。SPDY**允许给每个request设置优先级**，这样**重要的请求就会优先得到响应**。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。
3. **header压缩。**前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。
4. **基于HTTPS的加密协议传输**，大大提高了传输数据的可靠性。
5. **服务端推送**（server push），**采用了SPDY的网页**，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：

![img](.\image\1706626a996d717c9d424646578813c2.png)

SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能



### HTTP2.0：SPDY的升级版

HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：

**HTTP2.0和SPDY的区别：**

1. **HTTP2.0 支持明文 HTTP 传输**，而 **SPDY 强制使用 HTTPS**
2. HTTP2.0 消息头的压缩算法采用 **HPACK**，而非 SPDY 采用的 **DEFLATE**

### HTTP2.0和HTTP1.X相比的新特性

+ **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑**HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮**

  **帧：**HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成

  **流：**存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID

+ **多路复用**（MultiPlexing），即**连接共享**，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面

  **同个域名只需要占用一个 TCP 连接**，单个连接可以承载任意数量的双向数据流 

+ **header压缩**，如上文中所言，对前面提到过HTTP1.x的**header带有大量信息，而且每次都要重复发送**，HTTP2.0使用encoder来减少需要传输的header大小，**通讯双方各自cache一份header fields表**，由客户端和服务器共同渐进地更新。既避免了重复header的传输，又减小了需要传输的大小。

+ **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求 