迭代器失效分三种情况考虑，也是从三种数据结构考虑，分别为数组型，链表型，树型数据结构

+ 数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)(或erase(*iter))，然后在iter++，是没有意义的
  + 解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter)
+ 链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器
  + 解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++)*
+ 树形数据结构： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void
  + 所以要采用erase(iter++)的方式删除迭代器。
+ 注意：经过erase(iter)之后的迭代器完全失效，该迭代器iter不能参与任何运算，包括iter++、*ite



## vector迭代器

+ 使用erase不恰当使迭代器失效
+ 使用push_back导致迭代器失效（需要扩容时可能会）
+ 使用end返回的迭代器，如erase、pop_back