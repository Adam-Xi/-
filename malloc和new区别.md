# new与malloc的区别

1. 申请的内存所在位置：

   + new操作符从**自由存储区**上为对象动态分配内存空间。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。自由存储区不仅可以是堆，还可以是静态存储区。甚至，new甚至可以不为对象分配内存，定位new可以做到这一点

   + malloc函数从堆上动态分配内存

2. 返回类型安全性

   + new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，所以new是符合类型安全的操作符
   + malloc函数内存分配成功返回void* ，需要通过强制性转换将void* 指针转换成需要的类型

3. 内存分配失败时的返回值

   + new内存分配失败时，会抛出bac_alloc异常，并不会返回NULL
   + malloc分配内存失败时返回NULL

4. 是否需要指定内存大小

   + 使用new操作符申请内存分配时无需指定内存块的大小，编译器会根据类型信息自行计算
   + malloc需要显式地指出所需内存的大小

5. 是否调用构造函数 / 析构函数

   + new：
     1. 调用operator new / new[ ] 函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象
     2. 编译器运行相应的构造函数来构造对象，并为其传入初值
     3. 对象构造完成后，返回一个指向该对象的指针
   + delete：
     1. 调用对象的析构函数
     2. 编译器调用operator delete / delete[ ] 函数释放内存空间
   + malloc / free不会调用 构造函数 / 析构函数

6. 属性上：

   + new / delete 是C++关键字，需要编译器支持
   + malloc 是库函数，需要添加头文件stdlib.h

7. 重载

   + new / delete操作符可以被重载
   + malloc不允许重载

8. 重新分配内存：

   + malloc分配内存后，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域
   + new 不能够直观地重新分配内存

![1583850670326](./image/1583850670326.png)



堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价

+ 自由存储是C++中通过new与delete动态分配和释放对象的**抽象概念**，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。
+ new所申请的内存区域在C++中称为自由存储区。即由堆实现的自由存储，可以说new所申请的内存区域在堆上。
+ 堆与自由存储区还是有区别的，它们并非等价

但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了 