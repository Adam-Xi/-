# 线程安全
多线程同时在运行，同时去访问临界资源，不会对数据产生二义性，对程序的结果产生二义性

# 如何保证代码的线程安全

同步：保证了代码对临界资源的合理访问

互斥：保证了代码对临界资源的访问

# Linux线程同步的三种方法
+ 互斥锁
+ 条件变量
+ 信号量

## 互斥的实现
### 互斥锁

通过互斥量实现，本质上是一个计数器，而该计数器的取值：不是0就是1

计数器本身就是一个临界资源，这个计数器保证自己在修改数据的时候是一个原子操作，不被其他执行流所打断：
+ xchgb指令，将寄存器和内存中的值进行交换
+ 如果寄存器中的值为0，说明之前内存中变量的值为0，即，当前的临界资源不可用，加锁等待
+ 如果寄存器中的值为1，说明之前内存中变量的值为1，即，当前的临界资源是可用的，可以加锁

1. 初始化锁。在Linux下，线程的互斥量数据类型是pthread_mutex_t。在使用前,要对它进行初始化。

   > 静态分配：pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
   >
   > 动态分配：int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutex_attr_t *mutexattr);

2. 加锁。对共享资源的访问，要对互斥量进行加锁，如果互斥量已经上了锁，调用线程会阻塞，直到互斥量被解锁。

   > int pthread_mutex_lock(pthread_mutex *mutex);
   >
   > int pthread_mutex_trylock(pthread_mutex_t *mutex);

3. 解锁。在完成了对共享资源的访问后，要对互斥量进行解锁。

   > int pthread_mutex_unlock(pthread_mutex_t *mutex);

4. 销毁锁。锁在是使用完成后，需要进行销毁以释放资源。

   > int pthread_mutex_destroy(pthread_mutex *mutex);

### 死锁

简单讲，程序中有一个执行流没有释放锁资源，导致其他执行流（线程）无法获取锁的情况
复杂讲，程序中各个执行流（线程）都占有一把锁，但是由于各个执行流在占有锁的情况下仍想去申请对方锁的情况

###### 死锁的四个必要条件
+ 互斥条件：一把锁只能被一个线程所拥有
+ 请求与保持条件：保持，请求（吃着碗里的，看着锅里的）
+ 循环等待条件：若干个执行流（线程）之间请求锁资源的情况形成了一个闭环
+ 不可剥夺条件：其他线程不能帮当前线程释放锁资源

###### 避免死锁
+ 破坏四个必要条件
+ 加锁顺序一致
+ 避免锁未被释放的情况----要在代码所有可能推出的地方进行解锁
+ 一次性分配所有资源

## 同步的实现

同步保证了各个执行流对临界资源访问的合理性：当有资源的时候可以获取，没有资源的时候，让线程（执行流）进行等待，等待另一个线程（执行流）生产一个资源，唤醒需要访问资源而等待的线程

使用条件变量实现同步

### 条件变量的接口

1. 初始化条件变量。

   > 静态态初始化，pthread_cond_t cond = PTHREAD_COND_INITIALIER;
   >
   > 动态初始化，int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);

2. 等待条件成立。释放锁,同时阻塞等待条件变量为真才行。timewait()设置等待时间,仍未signal,返回ETIMEOUT(加锁保证只有一个线程wait)

   > int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
   >
   > int pthread_cond_timewait(pthread_cond_t *cond,pthread_mutex *mutex,const timespec *abstime);

3. 激活条件变量。pthread_cond_signal,pthread_cond_broadcast（激活所有等待线程）

   > int pthread_cond_signal(pthread_cond_t *cond);
   >
   > int pthread_cond_broadcast(pthread_cond_t *cond); //解除所有线程的阻塞

4. 清除条件变量。无线程等待,否则返回EBUSY

   > int pthread_cond_destroy(pthread_cond_t *cond);



+ 为什么需要互斥锁？
  条件变量只是保证了同步，消费者和生产者之间的同步，但是，生产者之间，消费者之间的冲突并没有进行保证
  条件变量增加互斥锁，是为了，通知消费者或者生产者，保证只有一个线程可以获取消费或者生产的信号。
  换句话说，当一个生产的线程产生了一份临界资源后，就唤醒了等待队列当中的线程，等待队列中的线程需要先获取互斥锁，来保证对临界资源的唯一访问
+ 如何使用互斥锁
  当线程调用pthread_cond_wait()后，现象是：当前调用的线程陷入阻塞状态
  第一步：将该线程（执行流）的PCB放到PCB等待队列中去
  【问题】为什么需要将线程PCB放到PCB等待队列之后才解锁
    假设一种并发的场景，有多个执行流想要对该临界资源进行访问
  都想要竞争互斥锁资源
    如果线程A的PCB没有被放到PCB等待队列中去，就将互斥锁资源
  放掉，此时如果线程B获取了锁资源，当线程A想要访问生产线程生产出来的临界资源时，线程A就会不知道临界资源被生产了，也就是因为线程A没有在PCB等待队列中，无法收到唤醒接口发送的唤醒信号
  第二步：对互斥锁进行解锁
  第三步：当线程被从PCB唤醒队列中唤醒之后，首先需要竞争互斥锁资源，对互斥锁进行加锁操作

### 信号量

信号量主要完成线程或者进程之间的同步、互斥

信号量本质上 是一个资源计数器 + 等待队列 + 对调用者提供的唤醒和阻塞的接口
比条件变量多了一个自带的计数器，这个计数器是对临界资源的计数。通过自身的计数器，来进行条件判断，是否可以对资源进行访问，若判断到不能够获取资源，则阻塞当前的执行流

在程序的初始化阶段，会根据资源的一个数量来初始化POSIX信号量，初始化资源计数器。当执行流需要获取资源的时候，调用信号量的接口，来判断信号量中的资源计数器是否大于0，如果是，则对信号量当中的资源计数器进行-1操作，然后直接返回，获取数据。反之，则阻塞该执行流



1. 信号量初始化。

   > int sem_init (sem_t *sem , int pshared, unsigned int value);

   这是对由sem指定的信号量进行初始化，设置好它的共享选项(linux 只支持为0，即表示它是当前进程的局部信号量)，然后给它一个初始值VALUE。

2. 等待信号量。给信号量减1，然后等待直到信号量的值大于0。

   > int sem_wait(sem_t *sem);

3. 释放信号量。信号量值加1。并通知其他等待线程。

   > int sem_post(sem_t *sem);

4. 销毁信号量。我们用完信号量后都它进行清理。归还占有的一切资源。

   > int sem_destroy(sem_t *sem);
