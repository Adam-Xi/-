# 多态
通俗来讲，同一事物，在不同场景下表现出不同的形态。如买票，普通成人买就是全价票，学生买就是半价票，军人买就是免票

### 多态的构成条件
在继承的体系下：
+ 基类中必须有虚函数（被virtual关键字修饰的成员函数），在派生类中必须要对基类中的虚函数重写
+ 对于虚函数调用，必须使用基类的指针或引用调用虚函数

多态性的体现：在代码运行时，基类指针指向哪个类的对象，就调用那个类的虚函数

### 虚函数重写（覆盖）
一定是派生类重写基类的虚函数
+ 一个函数在基类，一个函数在子类
+ 基类中成员函数必须是虚函数
+ 子类同名成员函数前virtual关键字是否添加都可以
+ 基类虚函数与子类虚函数原型必须相同（返回值、函数名、参数列表）

两个特例：
+ 协变（基类与派生类虚函数返回值类型不同）：基类中虚函数返回基类的指针（引用），子类中虚函数返回子类的指针（引用）
+ 析构函数（基类与派生类析构函数名不同）

### final：修饰虚函数，表示该虚函数不能被重写。若直接修饰基类，无意义，常用在“隔代重写”中
### override：检查派生类虚函数是否重写了基类某个虚函数，如果没有重写则编译报错。只能修饰派生类的虚函数

### 抽象类（接口类）
+ 在虚函数后面加上=0，则这个函数为纯虚函数，包含纯虚函数的类叫做抽象类
+ 抽象类不能被实例化出对象，派生类继承后也不能实例化出对象，只有重写纯虚函数后，派生类才能实例化出对象
+ 不能被实例化，但可以创建该类的指针
\n
作用：规范后续要实现的接口，体现接口继承

### 多态原理

+ 同一个类定义的多个对象共用同一张虚表。不同的类有不同的虚表，并不共用
+ 若派生类中重写了某基类虚函数，就用派生类自己的虚函数地址覆盖虚表中相同偏移量位置的函数地址
+ 派生类新增的虚函数，按其在派生类中的声明次序增加到虚表最后

**满足多态以后的函数调用是运行起来后到对象中去找的，不满足多态的函数调用是编译时确认好的** 

### 静态绑定

在程序编译期间确定了程序的行为，称为静态多态。如 函数重载 或 函数模板

### 动态绑定

在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数。虚函数+继承

----------------------------------------------------------------------------------------------------
# 函数重载
+ 两个函数在一个类的内部，相同作用域
+ 函数名相同，参数列表不同，返回值类型未作要求

# 函数重写（覆盖）：子类重新定义父类中的虚函数

+ 两个函数分别在基类和派生类中，不同作用域
+ 函数名、参数、返回值都必须相同（协变例外）
+ 两个函数必须是虚函数

# 函数重定义（同名函数隐藏）：子类重新定义父类中的非虚函数，派生类的函数屏蔽了与其同名的基类函数

+ 两个函数分别在基类和派生类，不同作用域
+ 函数名相同，参数列表可以不同，返回值未做要求
+ 两个基类和派生类的同名函数不构成重写就是重定义


# tips
+ inline函数不能作为虚函数，因为inline函数没有地址，无法把地址放到虚函数表中
+ static成员函数不能作为虚函数，因为static成员函数没有this指针，使用 类型::成员函数 的调用方式无法访问虚函数表，所以static成员函数无法放进虚函数表中
+ 构造函数不能是虚函数，因为对象中的虚函数指针是在构造函数初始化列表阶段才初始化的
+ 虚函数表是在编译阶段就生成的，一般情况下存在与代码段（常量区）的
