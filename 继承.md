# 继承
### 概念
> 继承机制是面向对象程序设计可以是代码复用的最重要的手段
> 继承允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生的类，称为派生类
> 继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知

举例：
将交通工具封装成一个类，该类的特性是能进行一定距离上的位移
让汽车、火车、飞机等类继承交通工具类，这些类被称为派生类，交通工具类被称为基类
这些派生类在交通工具类的特性基础上，各自增加各自的特性，由此实现了继承

### 基类和派生类对象赋值转换
+ 派生类可以赋值给基类的对象、指针、引用
+ 基类对象不能赋值给派生类对象
+ 基类指针可以通过强制类型转换赋值给派生类的指针，但是必须是基类的指针是指向派生类对象时才是安全的

### tips
+ 实现一个不能被继承的类：
  - C++98：构造函数私有化
  - C++11：类名后加final关键字禁止继承
+ 友元关系不能被继承，即基类友元不能访问子类私有和保护成员
+ 基类定义了static静态成员，则整个继承体系中只有一个这样的成员。无论派生出多少个子类，都只有一个static成员实例
+ 菱形继承有数据冗余和二义性问题，虚拟继承的唯一作用就是解决菱形继承的数据冗余和二义性问题

### 菱形继承的解决方法：
+ 访问明确化，如d.B::_a = 1;...
+ 让顶层接力中的成员在中间类中只存储一份

### 菱形虚拟继承
+ 菱形继承是多继承的一种特殊情况，即类B和类C分别继承类A，而类D同时继承类B和类C，此时形成菱形继承现象。菱形继承会造成数据冗余和二义性问题。
+ 虚拟继承的唯一作用就是用来解决菱形继承的数据冗余和二义性问题。在代码中的表现方式为，类B和类C分别继承类A时，在继承方式前分别加上virtual关键字，形如class B : public A {...}
+ 菱形虚拟继承是菱形继承和虚拟继承的结合，分别将中间类的继承方式前加virtual关键字修饰，从而能够解决菱形继承的缺陷，其原理为：
  - 使得顶层基类中的成员在中间类中只存储一份，如下：
  - 在中间类（类B、类C）中，最上面为一个指针变量，称为虚基表指针，虚基表指针指向一个虚基表，虚基类表每项记录了被继承的虚基类子对象相对于虚基类表指针的偏移量。

### tips
**需要杜绝“圆不是椭圆”的不良继承设计问题**


# 组合
若在逻辑上A 是B 的“一部分”（a part of），则不允许B 继承A 的功能，而是要用A和其它东西组合出B，它们之间就是“Has-A关系”。例如眼（Eye）、鼻（Nose）、口（Mouth）、耳（Ear）是头（Head）的一部分，所以类Head 应该由类Eye、Nose、Mouth、Ear 组合而成，不是派生而成。示例程序如下：

```cpp
class Eye
{
public:
　　void Look(void);
};

class Nose
{
public:
　　void Smell(void);
};

class Mouth
{
public:
　　void Eat(void);
};

class Ear
{
public:
　　void Listen(void);
};

// 正确的设计，冗长的程序
class Head
{
public:
　　void Look(void) { m_eye.Look(); }
　　void Smell(void) { m_nose.Smell(); }
　　void Eat(void) { m_mouth.Eat(); }
　　void Listen(void) { m_ear.Listen(); }
private:
　　Eye m_eye;
　　Nose m_nose;
　　Mouth m_mouth;
Ear m_ear;
};
```