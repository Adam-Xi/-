死锁是指一组进程中的各个进程均占有不会释放的资源，但因互相申请被其它进程所占用并不会释放的资源而处于的一种永久等待的状态

## 死锁的四个必要条件：

+ 互斥条件：一个资源同一时刻只能被一个执行流使用
+ 请求与保持条件：一个执行流因请求资源而阻塞时，对已获得的资源保持不放
+ 不可剥夺条件：一个执行流已获得的资源，在未使用完之前，不能强行释放
+ 循环等待条件：若干执行流之间形成一种头尾相连的循环等待资源的关系

## 避免死锁：

+ 破坏四个必要条件
+ 加锁顺序一致
+ 避免锁未释放的场景
+ 资源一次性分配

避免死锁的算法：

+ 死锁检测算法

+ 银行家算法

  > ## 算法原理
  >
  > 我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。
  >
  > 为保证资金的安全，银行家规定：
  >
  > (1) 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客；
  >
  > (2) 顾客可以分期贷款，但贷款的总数不能超过最大需求量；
  >
  > (3) 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款；
  >
  > (4) 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金.
  >
  > 操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配