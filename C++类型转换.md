+ static_cast：个人感觉就是为了替换C的显示类型转换。编译器对他们的处理方式非常相似，就是在编译期间获取类型信息，然后在派生类和基类的指针之间进行移动，获取最后的指针值

  但是不同的是，当在两种不存在继承关系的指针之间进行转换时，static_cast会在编译期间报错，禁止转换

  static_cast应用场合：继承体系中指针间的转换，基本类型之间的转换，涉及void*的转换

+ reinterpret_cast：任意的指针/引用类型的转换： int*类型的地址 -> uint32_t类型变量

+ const_cast：最常用的用途就是删除变量的const属性，方便修改变量内容

+ dynamic_cast：（动态转换），用于将一个父类对象的指针转换为子类的指针或引用：（安全的实现向下转换）

  向上转换：子类对象指针-> 父类对象指针（不需要转换，赋值兼容规则）

  向下转换：父类对象指针/引用 -> 子类对象指针/引用（用dynamic_cast转型是安全的）





首先，从效率上来说static_cast高于dynamic_cast；

其次，如果是“上行转换”，优先采用static_cast。因为大家都是通过位移的方式来实现的，都是不安全的。

然后，如果是“下行转换”，如果涉及虚基类到派生类的转换，或者需要对返回的值进行判断，那么才考虑dynamic_cast。使用dynamic_cast还是需要对返回值进行判断；使用static_cast需要使用者对原始指针的类型记在心中。