# STL为什么广泛被使用

C++ STL 之所以得到广泛的赞誉，也被很多人使用，不只是提供了像vector, string, list等方便的容器，更重要的是STL封装了许多复杂的数据结构算法和大量常用数据结构操作。vector封装数组，list封装了链表，map和set封装了二叉树等

# STL（Standard Template Library）

概念：通俗的说，STL是对常见数据结构的封装，和一些通用的算法，即可以操作任意类型数据和任意数据结构的算法

## 容器：存放数据

常见的数据结构--->：顺序和链式、树形结构、哈希结构

### 序列式容器：

C++98：

- string

  > 应用 + 常用接口 + 实现方式 ： 
  >
  > C语言中模拟实现str系列函数   
  >
  > mem系列函数
  >
  > strlen 和 sizeof 的区别
  >
  > 深拷贝  浅拷贝  写时拷贝

- vector：动态顺序表

  > 实现原理   扩容方式   使用场景
  >
  > 优缺点   迭代器失效---->怎么解决

- list：带头结点的双向循环链表

  > 为什么带头结点、为什么双向、为什么循环
  >
  > 优缺点    迭代器失效---->怎么解决
  >
  > vector 和 list 区别
  >
  > 数据结构中链表的相关内容：
  >
  > * 链表分类：带头与不带头的区别
  > * 链表（单链表&双向链表）的基本操作
  > * 链表的面试题

- deque：双端队列

  > 实现原理 底层结构
  >
  > deque 和 vector区别
  >
  > deque应用：STL->栈和队列 的底层结构
  >
  > stack & queue是特殊的容器  即对deque的封装，就是所谓的适配器
  >
  > * 适配器：stack：概念、特性、应用：模拟递归、逆波兰表达式、回溯法、实现队列
  > * queue：概念、特性、应用：二叉树层序遍历，实现栈          深度优先遍历和广度优先遍历
  > * 循环队列，满 空的条件
  > * 面试题

- 优先级队列

  > 实现原理，应用场景 TOP-K，默认情况下的排序方式                    

- 堆

  > 概念、特性、实现、堆排序

C++11：

- array：静态顺序表
- forward_list：带头节点的循环单链表

### 关联式容器：（按底层结构划分）

树形结构

> - map
>
> - set
>
> - multimap
>
> - multiset
>
>   以上容器的特性、区别、实现原理
>
>   红黑树：统计性能要好于一般的二叉平衡树

> * 二叉搜索树：概念、特性、实现、缺陷
> * AVL：概念、特性、实现原理、旋转
> * 红黑树：概念、特性、实现方式、插入过程、应用场景、优缺点
> * 红黑树与AVL的比较
> * map 和 set底层如何搭载红黑树

哈希结构

    unordered_map
    unordered_set
    unordered_multimap
    unordered_multiset
    实现原理、与map等容器的区别
     哈希：
        概念、作用、优缺点
        哈希冲突、哈希冲突的解决方法、闭散列和开散列、线性探测和二次探测
        负载因子
        位图和布隆过滤器
        海量数据面试题
        扩展：一致性哈希、哈希与加密的关系、MD5算法

## 算法：

容器相关的算法--->容器中的成员函数--->与数据结构相关的
通用类型的算法---->与数据结构无关

## 迭代器：设计模式的概念

概念 ：迭代器是一种对象，它能够用来遍历STL中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器是一种抽象的概念，可以把抽象容器和通用算法有机的统一起来。

​    迭代器分类：
​        原生态指针
​        对原生态指针的封装
​    如何给一个容器增加迭代器：
​        1、实现迭代器
​        2、在类中给迭代器取别名
​        3、begin、end
​    迭代器失效及解决
​    STL源码剖析

## 仿函数：

仿函数是函数对象--->可以使算法的功能更加灵活
实现方式：在类中将函数调用运算符()重载
lambda表达式----编译器在底层将其转化为仿函数进行处理

## 适配器

主要用来修饰容器接口、迭代器接口或仿函数接口

STL提供了stack、queue两种容器适配器，stack和queue的底层完全是由deque来实现的

改变容器接口称为容器适配器

改变迭代器接口称为迭代器适配器

改变仿函数接口称为仿函数适配器

## 空间配置器

主要用来给容器进行空间的配置和管理

从实现的角度来说空间配置器是实现了一个动态分配空间、空间管理、空间释放的类模板









--------

## 六大组件及其关系

+ Container(容器) 各种基本数据结构
+ Adapter(适配器) 可改变containers、Iterators或Function object接口的一种组件
+ Algorithm(算法) 各种基本算法如sort、search…等
+ Iterator(迭代器) 连接containers和algorithms
+ Function object(函数对象)
+ Allocator(分配器)

## 容器-Container

容器类是容纳、包含一组元素或元素集合的对象
七种基本容器：向量（vector）、双端队列（deque）、列表（list）、集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）

### 序列式容器

序列式容器Sequence containers, 其中每个元素均有固定位置——取决于插入时机和地点，和元素值无关。（vector、deque、list）

+ list:双向链表:

基于双向环状链表实现;尾部有空白节点（为满足左闭右开）；内部有一个 last 迭代器指向尾端空白节点（其 next 为 begin 迭代器）。
插入和删除快，但是随机访问比较慢,时间复杂度为O(1)；
需要频繁进行插入或删除操作且不需要过多地在序列内部进行长距离跳转，应该选择list
List 不能使用算法 sort（只接受随机存取迭代器），值接受双向迭代器，不支持随机存取迭代器，它有自己内置的 sort。

+ vector：动态数组，基于数组的实现，

从后面插入和删除元素,push_back,pop_back，随机访问快 ，插入和删除慢，因为会造成内存块的拷贝，时间复杂度为O(n)
迭代器在增加数据，内存扩容时必定失效，因为内存地址都变了，删除数据时看编译器情况，vs会失效。
维护三个迭代器：start，finish，end_of_storage；
内存分配：
vector动态数组只会增加内存，不会删除空间，当空间不够时会自动申请另一片更大的空间，然后把原有数据拷贝过去，并删除原来的空间的数据，但是存储空间不会释放，要等到vector调用析构函数的时候才会释放空间。
扩容原则是：
VS2015 下配对源码 每次扩容50%，原来空间大小9，扩容之后9+9/2=13;
Ubuntu 下源码是按每次增长两倍算；
若原本空间为0，第一次配置扩容为1，否则按1.5或2倍来来算
强制释放内存:.clear()函数只会清空数据，并不会释放内存，一般采用swap函数释放空间。通过创建临时拷贝对象，调用swap之后来释放原对象内存空间。vector< int>(v).swap(v);注意：这里的swap是泛型算法里的swap函数，不是容器里的。
注意：并不是所有的STL容器的clear成员函数的行为都和vector一样。事实上，其他容器的clear成员函数都会释放其内存。比如另一个和vector类似的顺序容器deque。

+ deque(双向队列):

与vector类似，也是基于数组，但是支持开始端插入元素：push_front；
与vector相比元素存取和迭代器动作稍慢，但是内存分配方面优于vector
c++标准建议：vector是那种应该在默认情况下使用的序列。如果大多数插入和删除操作发生在序列的头部或尾部时，应该选用deque。
使用中控器 map，存的指针，指向实际存储块
迭代器失效：
a. 在deque容器首部或者尾部插入元素不会使得任何迭代器失效；
b. 在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效；
c. 在deque容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效。

### 关联式容器

关联式容器Associative containers，元素位置取决于特定的排序准则以及元素值，和插入次序无关。（set、multiset、map、multimap）

+ set：

一对一， 内部结构采用红黑树的平衡二叉树。自动排序，默认升序，不允许重复值

+ multiset：类同set，允许重复值
+ map (key,value): 

一对多， 内部结构采用红黑树的平衡二叉树。自动排序，默认升序，不允许重复值

+ multimap:

类同map，允许重复值
红黑树：五大特性

每个节点或者是黑色，或者是红色。
根节点是黑色。
每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]
如果一个节点是红色的，则它的子节点必须是黑色的。
从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。


红黑树插入结点

因为红黑树上面的第4个特点，因此当向红黑树中插入新的节点时，应该将新节点标注为红色。向红黑树中插入节点看的是插入节点的父节点和叔父节点。

红黑树旋转

右旋
插入D结点，此时的树不满足红黑树性质，需要旋转，这里需要对A进行右旋转

以 A-B轴右旋，对A右旋，A成为B的右孩子，B的右孩子成为A的左孩子

同理，若需要左旋，则是以A-B轴右旋，对A左旋，A成为B的左孩子，B的左孩子成为A的右孩子



| 容器             | 特性                                                         | 所在头文件 |
| ---------------- | ------------------------------------------------------------ | ---------- |
| 向量vector       | 可以用常数时间访问和修改任意元素，在序列尾部进行插入和删除时，具有常数时间复杂度，对任意项的插入和删除就有的时间复杂度与到末尾的距离成正比，尤其对向量头的添加和删除的代价是惊人的高的 | <vector>   |
| 双端队列deque    | 基本上与向量相同，唯一的不同是，其在序列头部插入和删除操作也具有常量时间复杂度 | <deque>    |
| 表list           | 对任意元素的访问与对两端的距离成正比，但对某个位置上插入和删除一个项的花费为常数时间。 | <list>     |
| 队列queue        | 插入只可以在尾部进行，删除、检索和修改只允许从头部进行。按照先进先出的原则。 | <queue>    |
| 堆栈stack        | 堆栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项。即按照后进先出的原则 | <stack>    |
| 集合set          | 由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序，具有快速查找的功能。但是它是以牺牲插入删除操作的效率为代价的 | <set>      |
| 多重集合multiset | 和集合基本相同，但可以支持重复元素具有快速查找能力           | <set>      |
| 映射map          | 由{键，值}对组成的集合，以某种作用于键对上的谓词排列。具有快速查找能力 | <map>      |
| 多重集合multimap | 比起映射，一个键可以对应多了值。具有快速查找能力             | <map>      |



## 迭代器-Iterators

迭代器是泛化的指针，通过迭代器，编程人员可以无需关心关心其内部结构而进行操作数据 

每种容器都提供了自己的迭代器，这些迭代器能够了解容器内部的数据结构。
迭代器是一种智能指针，智能指针定义为存储指向动态分配对象指针的类，迭代器封装了指针的同时，还对指针的一些基本操作如*、->、++、==、!=、=进行了重载，使其具有了遍历复杂数据结构的能力，其遍历机制取决于所遍历的数据结构
迭代器分类：在STL中原生指针也是一种迭代器，除此之外还有五种迭代器

| 迭代器功能                       |                                                 |                                |
| -------------------------------- | ----------------------------------------------- | ------------------------------ |
| 输入迭代器Input iterator         | Reads forward                                   | istream                        |
| 输出迭代器Output iterator        | 向前写Writes forward                            | ostream,inserter               |
| 前向迭代器Forward iterator       | 向前读写Read and Writes forward                 |                                |
| 双向迭代器Bidirectional iterator | 向前向后读写Read and Writes forward andbackward | list,set,multiset,map,multimap |
| 随机迭代器Random access iterator | 随机读写Read and Write with randomaccess        | vector,deque,array,string      |

## 算法-Algorithm

算法Algorithms，用来处理群集内的元素。它们可以出于不同的目的而搜寻、排序、修改、使用那些元素。通过迭代器的协助，我们可以只需编写一次算法，就可以将它应用于任意容器，这是因为所有的容器迭代器都提供一致的接口。

## 适配器-Adapter

适配器是一种类，为已有的类提供新的接口，目的是简化、约束、使之安全、隐藏或者改变被修改类提供的服务集合
三种类型的适配器：

1. 容器适配器：stack，queue，priority_queue可以基于vector和deque，采用最大堆来实现，因为需要随机存取迭代器，只有这两个；

2. 迭代器适配器（反向迭代器、插入迭代器、IO流迭代器）
3. 函数适配器（函数对象适配器、成员函数适配器、普通函数适配器）

## 函数对象（仿函数）

一个行为类似函数的对象，它可以没有参数，也可以带有若干参数。
任何重载了调用运算符operator()的类的对象都满足函数对象的特征
函数对象可以把它称之为smart function。

仿函数(functor)，就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了 

仿函数(functor)又称之为函数对象（function object），其实就是重载了()操作符的struct，没有什么特别的地方 

STL中也定义了一些标准的函数对象，如果以功能划分，可以分为算术运算、关系运算、逻辑运算三大类。为了调用这些标准函数对象，需要包含头文件< functional >

## 分配器-allocator（*）：空间配置器

负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。
隐藏在这些容器后的内存管理工作是通过STL提供的一个默认的allocator实现的。当然，用户也可以定制自己的allocator，只要实现allocator模板所定义的接口方法即可，然后通过将自定义的allocator作为模板参数传递给STL容器，创建一个使用自定义allocator的STL容器对象，如：stl::vector< int, UserDefinedAllocator> array;
大多数情况下，STL默认的allocator就已经足够了。

这个allocator是一个由两级分配器构成的内存管理器，**当申请的内存大小大于128byte时，就启动第一级分配器通过malloc/free直接向系统的堆空间分配，如果申请的内存大小小于128byte时，就启动第二级分配器（内存池+自由链表）**，从一个预先分配好的内存池中取一块内存交付给用户，这个内存池由16个不同大小（8的倍数，8~128byte）的空闲列表组成，allocator会根据申请内存的大小（将这个大小round up成8的倍数）从对应的空闲块列表取表头块给用户。

这种做法有两个优点：
（1)小对象的快速分配。小对象是从内存池分配的，这个内存池是系统调用一次malloc分配一块足够大的区域给程序备用，当内存池耗尽时再向系统申请一块新的区域，整个过程类似于批发和零售，起先是由allocator向总经商批发一定量的货物，然后零售给用户，与每次都总经商要一个货物再零售给用户的过程相比，显然是快捷了。当然，这里的一个问题时，内存池会带来一些内存的浪费，比如当只需分配一个小对象时，为了这个小对象可能要申请一大块的内存池，但这个浪费还是值得的，况且这种情况在实际应用中也并不多见。
(2)避免了内存碎片的生成。程序中的小对象的分配极易造成内存碎片，给操作系统的内存管理带来了很大压力，系统中碎片的增多不但会影响内存分配的速度，而且会极大地降低内存的利用率。以内存池组织小对象的内存，从系统的角度看，只是一大块内存池，看不到小对象内存的分配和释放



![1584523365756](.\1584523365756.png)



# STL的缺陷

1. STL库更新慢
2. 没有支持线程安全，并发环境下需要自己加锁，且锁的粒度是比较大的
3. STL极度的追求效率，导致内部比较复杂
4. 在极端情况下，STL会导致内存膨胀的问题
5. 深拷贝问题，极端情况下，如果是百万级的数据，那么一次深拷贝就产生了几百万次的构造和析构