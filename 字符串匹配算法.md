在**主串**中找**子串**是否和**模式串**相等

#### BF算法：暴力匹配算法

![1584798936191](.\1584798936191.png)

不过，如果存在主串为aaaaaaaaaaaaab，而模式串为aaab，则此时时间复杂度为O(mn)

#### RK算法：回避字符串的直接比较

BF算法基础上，**引入Hash地址计算每个模式串长度的哈希值**，类似于滑动串口一样向后滑动，如果相等，则进行逐字符匹配，以防止哈希冲突；否则，减去当前滑动串口中第一位的哈希值，加上当前滑动窗口外第一位的哈希值，滑动窗口向后滑动，直到找到匹配项，或者滑动窗口滑动到主串末尾结束

时间复杂度为O(n)

#### BM算法：对BF的直接优化

为了减少比较，BM算法指定了两条规则：【坏字符规则】、【好后缀规则】

【坏字符规则】：“坏字符” 指模式串和子串当中不匹配时主串中的不匹配字符 

当子串和模式串不匹配时，BM算法规定检测顺序为从右向左检测，检测到的第一个不同的子串字符就是坏字符

在模式串中从左向右找和坏字符相等的字符，如果找到，就将模式串中的该字符定位在当前位置，并且将模式串中其他字符更新到当前位置；不存在找不到的情况，因为既然能够进行逐字符匹配，那么子串和模式串中必然存在相等字符

【好后缀规则】：“好后缀”指模式串和子串中相匹配的后缀

![1584800798881](.\1584800798881.png)

![1584800941767](.\1584800941767.png)

![1584801009272](.\1584801009272.png)

![1584801059522](.\1584801059522.png)



#### KMP算法：减少无谓的字符比较，较为注重已匹配前缀

